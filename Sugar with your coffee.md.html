<meta charset="utf-8" emacsmode="-*- markdown -*-">

**Sugar with your coffee**

*January 27, 2026*
*Will Dey*

```coffeescript
export desugar = ({ rules: sugared, rest... }) -> {
	rest...
	supertypes: ($) ->
		Array.from do collect = (rules = sugared) ->
			for key, value of rules when typeof value is 'object'
				yield from collect value
				yield $[key]
	rules: Object.assign(
		Object.fromEntries do flatten = (rules = sugared) ->
			for key, value of rules
				if typeof value is 'object'
					yield from flatten value
				else
					yield [key, value]
		Object.fromEntries do choices = (rules = sugared) ->
			for key, value of rules when typeof value is 'object'
				yield from choices value
				yield [
					key
					do (value) -> # Copy value in the returned lambda
						($) -> choice ($[subtype] for subtype in Object.keys value)...
				]
	)
}

export unthisify = (obj) ->
	for key, value of obj
		if typeof value is 'function'
			obj[key] = do (value) -> ($) -> value.bind($)()
		else if typeof value is 'object'
			unthisify value
	obj
```

And look how pretty!

```coffeescript
export default grammar desugar unthisify
	name: 'zine'
	extras: -> [] # Whitespace-sensitive language
	word: -> @identifier
	rules:
		text: -> seq @token, repeat seq ' ', @token
		punctuation: -> /[.!?:;,]/
		token:
			span: -> seq field('keyword', /[a-z]+\{/), @text, '}'
			word: -> /[^ \r\n{}]+/
			math:
				display: -> seq '{{', @expression, '}}'
				inline: -> seq '{', @expression, '}'

		_expression: -> choice(
			prec.left 2, seq ' ', @_expression
			@expression
		)
		expression:
			atom:
				identifier: -> /[a-zA-Z]+/
				integer: -> /[0-9]+/
				script:
					superscript: -> prec.right seq(
						choice @atom, @parens, @norm
						'^'
						choice @atom, @parens, @negation
					)
					subscript: -> prec.right seq(
						choice @atom, @norm
						'_'
						choice @atom, @parens, @negation
					)
				postfix: -> seq @atom, field 'operator', /[!#']/
			negation: -> prec 2, seq '-', choice @atom, @parens
			noncommutative: -> choice(
				prec.left 3, seq @_expression, ' ', @_expression
				prec.left seq @parens, @parens
			)
			commutative: -> prec.left 1, seq(
				@_expression
				field 'operator', choice ' + ', ' - '
				choice @_expression, @ellipsis
			)
			norm: -> seq '|', @expression, '|'
			set: -> seq '[', choice(@elements, seq @expression, '|', @expression), ']'
			bra: -> seq '<', @expression, '|'
			ket: -> seq '|', @expression, '>'
			projection: -> prec 1, seq '<', @expression, '|', @expression, '>'
			interval: -> seq(
				field 'start', choice '(', '['
				@expression, '..', @expression
				field 'end', choice ')', ']'
			)
			parens: -> seq '(', @expression, ')'
		elements: -> seq(
			@expression, ',', @expression
			repeat seq ',', @expression
			optional seq ',', @ellipsis, optional seq ',', @expression, repeat seq ',', @expression
		)
		ellipsis: -> '...'
```


<link rel="stylesheet" href="./style.css">
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
